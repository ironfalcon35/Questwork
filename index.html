<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Questwork 4.1</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body {
    margin:0;
    font-family:'Segoe UI', sans-serif;
    background: linear-gradient(135deg,#1f1c2c 0%,#928DAB 100%);
    color:#fff;
    min-height:100vh;
    display:flex;
    justify-content:center;
    align-items:center;
    flex-direction:column;
    text-align:center;
    transition:background 0.5s ease;
  }
  .card {
    background: rgba(0,0,0,0.6);
    padding:20px;
    border-radius:16px;
    box-shadow:0 8px 20px rgba(0,0,0,0.4);
    max-width:550px;
    width:95%;
    margin:10px;
    animation:fadeIn 0.5s ease-in;
  }
  h2,h3{margin-top:0;color:#ffdd57;text-shadow:1px 1px 4px #000;}
  input,button,select{
    width:90%;padding:12px;margin:8px 0;border-radius:8px;border:none;font-size:1rem;outline:none;
  }
  input{background:#f4f4f4;}
  button{
    background: linear-gradient(135deg,#ff6a00,#ee0979);
    color:white;font-weight:bold;cursor:pointer;transition:transform 0.2s,opacity 0.3s;
  }
  button:hover{transform:scale(1.05);opacity:0.9;}
  .hidden{display:none;}
  #inventory{list-style:none;padding:0;margin:0;max-height:150px;overflow-y:auto;}
  #inventory li{
    background: rgba(255,255,255,0.1);
    margin:5px 0;
    padding:8px;
    border-radius:6px;
    display:flex;
    justify-content:space-between;
    align-items:center;
  }
  .delete-btn{
    background: crimson;color:white;border:none;border-radius:6px;padding:3px 8px;cursor:pointer;font-size:0.8rem;
  }
  #wheelBox{
    margin:20px auto;
    width:250px;
    height:60px;
    overflow:hidden;
    border:3px solid #fff;
    border-radius:8px;
    background: rgba(0,0,0,0.8);
    display:flex;
    justify-content:center;
    align-items:center;
  }
  .prizeText{
    font-size:1.4rem;font-weight:bold;
    transition:transform 0.15s ease;
  }
  .theme-dog{background:url('https://i.imgur.com/9i5G79G.jpg') center/cover;}
  .theme-pirate{background:url('https://i.imgur.com/m5mG93q.jpeg') center/cover;}
  .theme-neon{background:linear-gradient(135deg,#0f0f0f,#00ffcc);}
  .theme-spooky{background:url('https://i.imgur.com/jyCOb3u.jpg') center/cover;}
  @keyframes fadeIn{
    from{opacity:0;transform:translateY(10px);}
    to{opacity:1;transform:translateY(0);}
  }
  /* Teacher section styles */
  #teacherLoginBtn{
    width:auto;
    padding:6px 12px;
    font-size:0.9rem;
    margin-top:15px;
    background:linear-gradient(135deg,#555,#999);
  }
  #teacherPanel{margin-top:20px;}

  /* Dungeon styles */
  #dungeonContainer{margin-top:12px;}
  #dungeonCanvas{display:block;margin:10px auto;border-radius:8px;background:#000;}
  #dungeonHUD{display:flex;justify-content:space-between;align-items:center;margin:8px 6px;font-weight:bold;}
  #mobileControls{display:flex;flex-direction:column;gap:6px;align-items:center;}
  #mobileControls > div{display:flex;gap:6px;}
  .smallBtn{padding:8px 12px;font-size:1rem;border-radius:8px;}
  #dungeonOverlay{position:relative;}
  #fullscreenBtn{position:absolute;right:6px;top:6px;padding:6px 10px;font-size:0.9rem;border-radius:6px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.08);}
  /* Responsive */
  @media (max-width:600px){
    #dungeonCanvas{width:92vw;height:92vw;}
  }
</style>
</head>
<body>
<div class="card" id="loginCard">
<h2>Questwork Login</h2>
<input type="text" id="username" placeholder="Username">
<input type="password" id="password" placeholder="Password">
<button onclick="signup()">Sign Up</button>
<button onclick="login()">Sign In</button>
</div>

<div class="card hidden" id="gameBox">
<h2>Welcome, <span id="playerName"></span>!</h2>
<p>⭐ Points: <span id="points">0</span></p>

<div id="wheelButtons">
<button onclick="spin()">Spin Wheel</button>
</div>

<div id="wheelBox"><div class="prizeText" id="prizeDisplay">?</div></div>
<p id="result"></p>

  <!-- Add this button under the wheel -->
<button onclick="startDungeon()">Play Dungeon</button>

<!-- Dungeon game container -->
<div id="dungeonContainer" class="hidden">
  <div id="dungeonOverlay">
    <div id="dungeonHUD">
      <div>Lives: <span id="dLives">0</span></div>
      <div>Level: <span id="dLevel">0</span></div>
      <div>Dungeon Score: <span id="dScore">0</span></div>
    </div>
    <button id="fullscreenBtn" onclick="toggleFullscreen()">⤢ Fullscreen</button>
    <canvas id="dungeonCanvas" width="480" height="480" style="border:3px solid white"></canvas>
  </div>

  <div id="mobileControls" class="hidden">
    <button class="smallBtn" onclick="movePlayer(0,-1)">⬆️</button>
    <div>
      <button class="smallBtn" onclick="movePlayer(-1,0)">⬅️</button>
      <button class="smallBtn" onclick="movePlayer(1,0)">➡️</button>
    </div>
    <button class="smallBtn" onclick="movePlayer(0,1)">⬇️</button>
    <button class="smallBtn" onclick="attack()">⚔️</button>
  </div>
  <div style="margin-top:8px;display:flex;gap:8px;justify-content:center;">
    <button onclick="exitDungeon()">Exit Dungeon</button>
    <button onclick="teleportHome()" title="Quick restart room (costs no points)">Regenerate Room</button>
  </div>
  <p style="font-size:0.85rem;margin-top:8px;color:#ddd">Tip: collect golden squares for points, red hearts are rare extra lives, and blue orbs are temporary shields.</p>
</div>

<script>
/* === Dungeon Game (UPGRADED) === */
const tileSize=32;
const mapSize=15; // 15x15
let dungeonGame=null;
const CONTINUE_COST = 200; // points to continue on death (big cost)
const REPLAY_COST = 400;   // if you want to fully replay/reset but keep account points (optional flow)

function startDungeon(){
  if(!currentUser) return alert("Sign in first!");
  document.getElementById("gameBox").classList.add("hidden");
  document.getElementById("dungeonContainer").classList.remove("hidden");
  // ensure account structure
  if(!accounts[currentUser].dungeon){
    accounts[currentUser].dungeon={
      lives:3,
      level:1,
      score:0,
      player:{x:7,y:7},
      enemies:[],
      items:[],
      map:[],
      lastSaved:Date.now()
    };
    saveData();
  }
  dungeonGame=new DungeonGame(currentUser);
  // show mobile controls if touch device
  if(('ontouchstart' in window) || navigator.maxTouchPoints>0){
    document.getElementById("mobileControls").classList.remove("hidden");
  } else {
    document.getElementById("mobileControls").classList.add("hidden");
  }
}

function exitDungeon(){
  if(dungeonGame){
    dungeonGame.destroy();
    dungeonGame=null;
  }
  saveData();
  document.getElementById("dungeonContainer").classList.add("hidden");
  document.getElementById("gameBox").classList.remove("hidden");
}

function teleportHome(){
  if(dungeonGame) dungeonGame.generateRoom(true);
}

/* Utility */
function randInt(n){return Math.floor(Math.random()*n);}
function sign(x){return x>0?1:(x<0?-1:0);}

class DungeonGame{
  constructor(user){
    this.user=user;
    this.canvas=document.getElementById("dungeonCanvas");
    this.ctx=this.canvas.getContext("2d");
    this.tile=tileSize;
    this.mapSize=mapSize;
    this.running=true;
    this.loadFromAccount();
    this.setupControls();
    // start loop & autosave
    this.lastSave=0;
    this.loop();
    this.autosaveInterval=setInterval(()=>this.save(),1000);
  }

  loadFromAccount(){
    const save=accounts[this.user].dungeon || {};
    // load or defaults
    this.lives = save.lives ?? 3;
    this.level = save.level ?? 1;
    this.score = save.score ?? 0;
    this.player = save.player ?? {x:7,y:7};
    this.enemies = save.enemies ?? [];
    this.items = save.items ?? [];
    this.map = save.map && save.map.length ? save.map : [];
    // if map empty, generate initial
    if(!this.map.length){
      this.generateRoom();
    }
    this.updateHUD();
  }

  save(){
    accounts[this.user].dungeon = {
      lives:this.lives,
      level:this.level,
      score:this.score,
      player:this.player,
      enemies:this.enemies,
      items:this.items,
      map:this.map,
      lastSaved:Date.now()
    };
    saveData();
  }

  destroy(){
    this.running=false;
    window.removeEventListener("keydown",this._keyHandler);
    clearInterval(this.autosaveInterval);
    this.save();
  }

  setupControls(){
    this._keyHandler = e=>{
      if(e.repeat) return;
      if(e.key==="w"||e.key==="ArrowUp") this.move(0,-1);
      if(e.key==="s"||e.key==="ArrowDown") this.move(0,1);
      if(e.key==="a"||e.key==="ArrowLeft") this.move(-1,0);
      if(e.key==="d"||e.key==="ArrowRight") this.move(1,0);
      if(e.key===" ") this.attack();
    };
    window.addEventListener("keydown",this._keyHandler);
  }

  generateRoom(preservePlayer=false){
    // generate walkable corridors-ish map (cellular-ish)
    const m=[];
    for(let y=0;y<this.mapSize;y++){
      m[y]=[];
      for(let x=0;x<this.mapSize;x++){
        // border walls
        if(x===0||y===0||x===this.mapSize-1||y===this.mapSize-1){ m[y][x]="#"; continue; }
        // create open-ish patterns
        m[y][x] = Math.random()<0.18 ? "#" : ".";
      }
    }
    // guarantee center area open
    const cx=Math.floor(this.mapSize/2), cy=Math.floor(this.mapSize/2);
    for(let dy=-2;dy<=2;dy++){
      for(let dx=-2;dx<=2;dx++){
        const sx=cx+dx, sy=cy+dy;
        if(sx>0 && sy>0 && sx<this.mapSize-1 && sy<this.mapSize-1) m[sy][sx]=".";
      }
    }
    // Place player at saved position if valid, else center
    if(!preservePlayer || !this.isWalkable(this.player.x,this.player.y)){
      this.player.x=cx; this.player.y=cy;
    }
    // enemies spawn based on level
    const enemyCount = Math.max(2, 3 + Math.floor(this.level * 0.8));
    const enemies=[];
    let attempts=0;
    while(enemies.length<enemyCount && attempts<500){
      attempts++;
      const ex=randInt(this.mapSize), ey=randInt(this.mapSize);
      if(this.isWalkable(ex,ey) && !(ex===this.player.x && ey===this.player.y)){
        enemies.push({x:ex,y:ey,shielded:false});
      }
    }
    // items: rare extra life, somewhat more likely points, occasional power-ups
    const items=[];
    if(Math.random()<0.06) items.push({x:randInt(this.mapSize),y:randInt(this.mapSize),type:"life"});
    if(Math.random()<0.4) items.push({x:randInt(this.mapSize),y:randInt(this.mapSize),type:"points",amount:10+randInt(41)});
    if(Math.random()<0.12) items.push({x:randInt(this.mapSize),y:randInt(this.mapSize),type:"shield",duration:8}); // temporary shield
    // ensure items are on walkable tiles and not overlapping player
    this.items = items.filter(it=>this.isWalkable(it.x,it.y) && !(it.x===this.player.x && it.y===this.player.y));
    this.enemies = enemies;
    this.map = m;
    // small chance to spawn a single VERY rare extra life later as roaming item (not on map)
    if(Math.random()<0.02){
      // spawn as item somewhere
      let rx,ry,tries=0;
      do{rx=randInt(this.mapSize);ry=randInt(this.mapSize);tries++;} while((!this.isWalkable(rx,ry) || (rx===this.player.x&&ry===this.player.y)) && tries<200);
      if(tries<200) this.items.push({x:rx,y:ry,type:"life"});
    }
    this.updateHUD();
  }

  isWalkable(x,y){
    return x>=0 && y>=0 && x<this.mapSize && y<this.mapSize && this.map[y][x] === ".";
  }

  draw(){
    const ctx=this.ctx, ts=this.tile;
    // scale canvas to fit CSS size if responsive
    // clear
    ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
    // background
    ctx.fillStyle="#000"; ctx.fillRect(0,0,this.canvas.width,this.canvas.height);

    // draw tiles
    for(let y=0;y<this.mapSize;y++){
      for(let x=0;x<this.mapSize;x++){
        if(this.map[y][x]==="#"){
          ctx.fillStyle="#444"; ctx.fillRect(x*ts,y*ts,ts,ts);
        } else {
          ctx.fillStyle="#0b0b0b"; ctx.fillRect(x*ts,y*ts,ts,ts);
          // subtle grid
          ctx.strokeStyle="rgba(255,255,255,0.02)";
          ctx.strokeRect(x*ts,y*ts,ts,ts);
        }
      }
    }

    // items
    for(const it of this.items){
      if(it.type==="life"){
        ctx.fillStyle="red";
        ctx.beginPath(); ctx.arc(it.x*ts+ts/2, it.y*ts+ts/2, ts*0.28, 0, Math.PI*2); ctx.fill();
      } else if(it.type==="points"){
        ctx.fillStyle="gold";
        ctx.fillRect(it.x*ts+ts*0.2, it.y*ts+ts*0.2, ts*0.6, ts*0.6);
      } else if(it.type==="shield"){
        ctx.fillStyle="deepskyblue";
        ctx.beginPath(); ctx.arc(it.x*ts+ts/2, it.y*ts+ts/2, ts*0.24, 0, Math.PI*2); ctx.fill();
      }
    }

    // enemies
    for(const e of this.enemies){
      ctx.fillStyle = e.shielded ? "orange" : "lime";
      ctx.fillRect(e.x*ts+ts*0.08, e.y*ts+ts*0.08, ts*0.84, ts*0.84);
    }

    // player
    ctx.fillStyle = (this.playerShieldActive? "cyan" : "#00ffff");
    ctx.fillRect(this.player.x*ts+ts*0.08, this.player.y*ts+ts*0.08, ts*0.84, ts*0.84);
    // HUD text overlay handled via DOM to keep crisp
  }

  updateHUD(){
    document.getElementById("dLives").innerText=this.lives;
    document.getElementById("dLevel").innerText=this.level;
    document.getElementById("dScore").innerText=this.score;
    document.getElementById("points").innerText = accounts[this.user].points;
  }

  move(dx,dy){
    if(!this.running) return;
    const nx=this.player.x+dx, ny=this.player.y+dy;
    if(nx<0||ny<0||nx>=this.mapSize||ny>=this.mapSize) return;
    if(this.map[ny][nx]==="#") return;
    this.player.x=nx; this.player.y=ny;
    // check items
    this.items = this.items.filter(it=>{
      if(it.x===nx && it.y===ny){
        if(it.type==="life"){
          this.lives++;
          this.score += 25;
          accounts[this.user].points += 5; // small bonus to account
        } else if(it.type==="points"){
          const amt = it.amount || 10;
          this.score += amt;
          accounts[this.user].points += amt;
        } else if(it.type==="shield"){
          this.playerShieldActive=true;
          this.playerShieldUntil = Date.now() + ((it.duration || 8) * 1000);
        }
        this.updateHUD();
        return false; // removed
      }
      return true;
    });

    // check collision with enemies currently on tile
    for(const e of this.enemies){
      if(e.x===nx && e.y===ny){
        // if player shield active, destroy enemy instead
        if(this.playerShieldActive){
          this.enemies = this.enemies.filter(x=>x!==e);
          this.score += 10;
          accounts[this.user].points += 2;
          this.updateHUD();
        } else {
          this.lives--;
          this.updateHUD();
          if(this.lives<=0){ this.handleDeath(); return; }
        }
      }
    }
  }

  attack(){
    // clear adjacent enemies (manhattan distance 1)
    const before = this.enemies.length;
    this.enemies = this.enemies.filter(e=>{
      const dist = Math.abs(e.x - this.player.x) + Math.abs(e.y - this.player.y);
      if(dist<=1){
        this.score += 8; accounts[this.user].points += 2;
        return false; // removed
      }
      return true;
    });
    if(this.enemies.length < before) this.updateHUD();
  }

  moveEnemies(){
    // Each enemy moves one step towards player (simple greedy) but respects walls.
    for(const e of this.enemies){
      // occasionally make an enemy 'dumb' and move randomly
      if(Math.random()<0.12){
        const dir = [[1,0],[-1,0],[0,1],[0,-1]][randInt(4)];
        const nx=e.x+dir[0], ny=e.y+dir[1];
        if(this.isWalkable(nx,ny) && !(nx===this.player.x && ny===this.player.y)){
          e.x=nx; e.y=ny;
        }
        // if moves onto player
        if(e.x===this.player.x && e.y===this.player.y){
          this.resolveEnemyCollision(e);
        }
        continue;
      }

      const dx = this.player.x - e.x, dy = this.player.y - e.y;
      // prefer longer axis
      let stepX = 0, stepY = 0;
      if(Math.abs(dx) >= Math.abs(dy)) stepX = sign(dx);
      else stepY = sign(dy);
      // try preferred move, fallback to other axis, fallback to random
      let tried=false;
      if(stepX!==0){
        if(this.isWalkable(e.x+stepX,e.y) && !(e.x+stepX===e.x && e.y===this.player.y)){
          e.x+=stepX; tried=true;
        }
      }
      if(!tried && stepY!==0){
        if(this.isWalkable(e.x,e.y+stepY)){
          e.y+=stepY; tried=true;
        }
      }
      if(!tried){
        const dir = [[1,0],[-1,0],[0,1],[0,-1]][randInt(4)];
        if(this.isWalkable(e.x+dir[0], e.y+dir[1])){
          e.x+=dir[0]; e.y+=dir[1];
        }
      }
      // collision with player
      if(e.x===this.player.x && e.y===this.player.y){
        this.resolveEnemyCollision(e);
      }
    }
  }

  resolveEnemyCollision(e){
    if(this.playerShieldActive){
      // shield destroys enemy
      this.enemies = this.enemies.filter(x=>x!==e);
      this.score += 10; accounts[this.user].points += 2;
      this.updateHUD();
      return;
    }
    this.lives--;
    this.updateHUD();
    if(this.lives<=0){ this.handleDeath(); return; }
  }

  handleDeath(){
    // pause running
    this.running=false;
    this.save(); // ensure latest saved
    // Offer costly continue if player has enough account points
    const acc=accounts[this.user];
    if(acc.points >= CONTINUE_COST){
      const want = confirm(`You died! Spend ${CONTINUE_COST} points to continue (keeps your dungeon progress)?`);
      if(want){
        acc.points -= CONTINUE_COST;
        this.lives = 3;
        this.running=true;
        this.updateHUD();
        this.save();
        return;
      }
    }
    // Offer expensive replay (reset dungeon but let them play again from scratch) if they have enough
    if(acc.points >= REPLAY_COST){
      const want2 = confirm(`You died! Spend ${REPLAY_COST} points to replay (reset dungeon to level 1)?`);
      if(want2){
        acc.points -= REPLAY_COST;
        // reset dungeon progress
        accounts[this.user].dungeon = null;
        saveData();
        alert("Dungeon reset. You can re-enter to start fresh.");
        exitDungeon();
        return;
      }
    }
    // No continue spent: lose dungeon progress completely
    alert("You died and didn't continue. Dungeon progress lost.");
    accounts[this.user].dungeon = null;
    saveData();
    exitDungeon();
  }

  checkProgression(){
    // If all enemies cleared, advance level & generate new room
    if(this.enemies.length===0){
      this.level++;
      // reward points for clearing
      this.score += 30 + randInt(30);
      accounts[this.user].points += 15 + randInt(10);
      this.generateRoom(true); // preserve player at center-ish
    }
  }

  loop(){
    if(!this.running) return;
    // enemy moves occasionally (throttle)
    if(!this._lastEnemyMove || Date.now() - this._lastEnemyMove > Math.max(350 - this.level*10, 120)){
      this.moveEnemies();
      this._lastEnemyMove = Date.now();
    }
    // shield expiration
    if(this.playerShieldActive && Date.now() > this.playerShieldUntil){
      this.playerShieldActive = false;
    }
    // occasionally spawn tiny items
    if(Math.random()<0.008){
      // spawn a small points item somewhere walkable
      let rx,ry,tries=0;
      do{rx=randInt(this.mapSize);ry=randInt(this.mapSize);tries++;} while((!this.isWalkable(rx,ry) || (rx===this.player.x&&ry===this.player.y)) && tries<200);
      if(tries<200) this.items.push({x:rx,y:ry,type:"points",amount:5+randInt(11)});
    }
    // draw & update
    this.draw();
    this.checkProgression();
    this.saveIfNeeded();
    this.updateHUD();
    // loop
    if(this.running) requestAnimationFrame(()=>this.loop());
  }

  saveIfNeeded(){
    if(Date.now() - (this.lastSave||0) > 1000){
      this.save();
      this.lastSave = Date.now();
    }
  }
}

/* External helper functions used by buttons/DOM */
function movePlayer(dx,dy){ if(dungeonGame) dungeonGame.move(dx,dy); }
function attack(){ if(dungeonGame) dungeonGame.attack(); }

function toggleFullscreen(){
  const el = document.getElementById("dungeonCanvas");
  if(!document.fullscreenElement){
    if(el.requestFullscreen) el.requestFullscreen();
    else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  } else {
    if(document.exitFullscreen) document.exitFullscreen();
    else if(document.webkitExitFullscreen) document.webkitExitFullscreen();
  }
}

// small helper to keep UI points in sync if points changed outside game
setInterval(()=>{
  if(currentUser) document.getElementById("points").innerText = accounts[currentUser].points;
},1000);

</script>


<h3>Inventory</h3>
<ul id="inventory"></ul>

<h3>Theme Selector</h3>
<select id="themeSelect" onchange="applyTheme(this.value)">
<option value="">--Choose Theme--</option>
</select>

<!-- Teacher toggle -->
<button id="teacherLoginBtn" onclick="showTeacherLogin()">Teacher</button>
<div id="teacherPanel" class="hidden">
  <h3>Teacher Controls</h3>
  <input type="number" id="pointsToAdd" placeholder="Points to add">
  <button onclick="addPoints()">Add Points</button>
  <button onclick="logoutTeacher()">Log Out</button>
</div>
</div>

<script>
const TEACHER_SECRET="QUEST123";

const wheelPrizes=[
  {name:"Sticker Pack",weight:4,refund:2},
  {name:"Dog Theme",weight:2,type:"theme"},
  {name:"Pencil Upgrade",weight:3},
  {name:"Pirate Theme",weight:1,type:"theme"},
  {name:"Neon Theme",weight:1,type:"theme"},
  {name:"Spooky Theme",weight:1,type:"theme"},
  {name:"1 Bonus Point",weight:2,type:"points",amount:1},
  {name:"50 Bonus Points",weight:1,type:"points",amount:50}
];

let accounts=JSON.parse(localStorage.getItem("accounts"))||{};
let currentUser=null;
let teacherMode=false;

function saveData(){localStorage.setItem("accounts",JSON.stringify(accounts));}

function signup(){
  let u=document.getElementById("username").value;
  let p=document.getElementById("password").value;
  if(!u||!p)return alert("Enter username and password.");
  if(accounts[u])return alert("Account exists!");
  accounts[u]={password:p,points:0,inventory:[],themes:[],selectedTheme:""};
  saveData();currentUser=u;startGame();
}

function login(){
  let u=document.getElementById("username").value;
  let p=document.getElementById("password").value;
  if(!accounts[u])return alert("No account. Sign up first.");
  if(accounts[u].password!==p)return alert("Wrong password.");
  currentUser=u;startGame();
}

function startGame(){
  document.getElementById("playerName").innerText=currentUser;
  updateUI();
  document.getElementById("loginCard").classList.add("hidden");
  document.getElementById("gameBox").classList.remove("hidden");
}

function weightedRandom(items){
  let total=items.reduce((sum,i)=>sum+i.weight,0);
  let r=Math.random()*total;
  for(let i of items){if(r<i.weight)return i;r-=i.weight;}
}

function spin(){
  let acc=accounts[currentUser];
  if(acc.points<5)return alert("Not enough points!");
  acc.points-=5;

  let prize=weightedRandom(wheelPrizes);
  let prizeDisplay=document.getElementById("prizeDisplay");
  let result=document.getElementById("result");

  let flips=30,step=0,interval=50;
  let anim=setInterval(()=>{
    step++;
    let fake=wheelPrizes[Math.floor(Math.random()*wheelPrizes.length)].name;
    prizeDisplay.innerText=fake;
    // scale bounce instead of vertical bounce
    let scale=1+0.2*Math.sin(step*0.8);
    prizeDisplay.style.transform=`scale(${scale})`;
    if(step>=flips){
      clearInterval(anim);
      prizeDisplay.innerText=prize.name;
      prizeDisplay.style.transform="scale(1)";
      let acc=accounts[currentUser];
      let already=acc.inventory.includes(prize.name)||acc.themes.includes(prize.name.split(" ")[0].toLowerCase());
      if(already&&prize.type!=="points"){
        acc.points+=prize.refund||5;
        result.innerText=`Duplicate! Refunded ${prize.refund||5} pts.`;
      } else{
        if(prize.type==="points")acc.points+=prize.amount;
        else if(prize.type==="theme")acc.themes.push(prize.name.split(" ")[0].toLowerCase());
        else acc.inventory.push(prize.name);
        result.innerText=`🎉 You won: ${prize.name}`;
      }
      updateUI();
    }
    interval+=10;
  },interval);
}

function updateUI(){
  let acc=accounts[currentUser];
  document.getElementById("points").innerText=acc.points;
  let inv=document.getElementById("inventory");
  inv.innerHTML="";
  acc.inventory.forEach((item,idx)=>{
    let li=document.createElement("li");li.innerText=item;
    let del=document.createElement("button");del.innerText="x";del.className="delete-btn";
    del.onclick=()=>{acc.inventory.splice(idx,1);updateUI();}
    li.appendChild(del);inv.appendChild(li);
  });
  let themeSelect=document.getElementById("themeSelect");
  themeSelect.innerHTML="<option value=''>--Choose Theme--</option>";
  acc.themes.forEach(t=>{
    let opt=document.createElement("option");opt.value=t;opt.innerText=t[0].toUpperCase()+t.slice(1)+" Theme";
    if(t===acc.selectedTheme)opt.selected=true;
    themeSelect.appendChild(opt);
  });
  if(acc.selectedTheme)applyTheme(acc.selectedTheme);
  saveData();
}

function applyTheme(theme){
  let acc=accounts[currentUser];
  acc.selectedTheme=theme;
  document.body.className="";
  if(theme)document.body.classList.add("theme-"+theme);
  saveData();
}

/* Teacher controls */
function showTeacherLogin(){
  if(teacherMode) return; // already logged in
  let code=prompt("Enter teacher code:");
  if(code===TEACHER_SECRET){
    teacherMode=true;
    document.getElementById("teacherPanel").classList.remove("hidden");
    document.getElementById("teacherLoginBtn").classList.add("hidden");
  } else {
    alert("Wrong code!");
  }
}
function addPoints(){
  let amt=parseInt(document.getElementById("pointsToAdd").value);
  if(teacherMode&&amt>0){accounts[currentUser].points+=amt;updateUI();alert("Added "+amt+" points!");}
  else alert("Enter a valid amount!");
}
function logoutTeacher(){
  teacherMode=false;
  document.getElementById("teacherPanel").classList.add("hidden");
  document.getElementById("teacherLoginBtn").classList.remove("hidden");
}
</script>
</body>
</html>
